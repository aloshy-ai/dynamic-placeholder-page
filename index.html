<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Placeholder Page | aloshy.ðŸ…°ðŸ…¸</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            font-family: Arial, sans-serif;
        }

        .background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            object-fit: cover;
            transition: opacity 2s ease-in-out;
            animation: kenBurns 20s ease-in-out infinite alternate;
            animation-play-state: paused;
        }

        .background.active {
            opacity: 1;
            animation-play-state: running;
        }

        @keyframes kenBurns {
            0% {
                transform: scale(1) translate(0, 0);
            }
            25% {
                transform: scale(1.05) translate(-1%, -1%);
            }
            75% {
                transform: scale(1.08) translate(1%, 1%);
            }
            100% {
                transform: scale(1.12) rotate(1deg);
            }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                    45deg,
                    rgba(255, 100, 100, 0.6),
                    rgba(100, 100, 255, 0.6),
                    rgba(100, 255, 100, 0.6),
                    rgba(255, 100, 100, 0.6),
                    rgba(100, 100, 255, 0.6)
            );
            mix-blend-mode: overlay;
            animation: gradientFlow 8s linear infinite;
            background-size: 400% 400%;
        }

        @keyframes gradientFlow {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        .credits-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-text {
            display: flex;
            align-items: center;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .credits-link {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 0.75rem;
            background-color: rgba(31, 41, 55, 0.9);
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s;
            color: rgb(229, 231, 235);
            text-decoration: none;
            font-family: system-ui, -apple-system, sans-serif;
            font-weight: 100;
        }

        .credits-link:hover {
            background-color: rgb(31, 41, 55);
            cursor: pointer;
        }

        .credits-logo {
            height: 0.8rem;
        }

        .logo-text-mono {
            font-family: monospace;
        }

        .logo-text-a {
            color: rgb(239, 68, 68);
        }

        .logo-text-i {
            color: white;
        }
    </style>
</head>
<body>
<div class="background-container">
    <img class="background" alt="Dynamic background">
    <img class="background" alt="Dynamic background">
</div>
<div class="overlay"></div>
<div class="credits-container">
    <div class="logo-section">
        <div class="logo-text">
            <span class="logo-text-mono">aloshy.</span>
            <span class="flex items-center">
                    <span class="logo-text-a">ðŸ…°</span>
                    <span class="logo-text-i">ðŸ…¸</span>
                </span>
        </div>
    </div>
    <div class="credits-banner">
        <a href="https://civitai.com" target="_blank" rel="noopener noreferrer" class="credits-link">
            <span>SOURCE</span>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 107 22.7" class="credits-logo">
                <defs>
                    <linearGradient id="prideGradient" gradientTransform="rotate(45)">
                        <stop offset="0%" stop-color="#E04A4A"/>
                        <stop offset="20%" stop-color="#E04A4A"/>
                        <stop offset="40%" stop-color="#E0B54A"/>
                        <stop offset="60%" stop-color="#4AE0D4"/>
                        <stop offset="80%" stop-color="#4A6AE0"/>
                        <stop offset="100%" stop-color="#D44AE0"/>
                    </linearGradient>
                </defs>
                <g>
                    <path fill="rgb(229, 231, 235)" d="M20.8,1.7H3.7L1.5,4.1v15l2.3,2.3h17.1v-5.2H6.7V7h14.1V1.7z"/>
                    <path fill="rgb(229, 231, 235)"
                          d="M76.1,1.7H56.6V7h7.2v14.3H69V7h7C76,7,76.1,1.7,76.1,1.7z M23.2,1.8v19.5h5.2V1.8C28.4,1.8,23.2,1.8,23.2,1.8z M30.8,1.8 v19.5h7.6l8.3-8.3V1.8h-5.2v8.3l-5.4,6V1.8C36.1,1.8,30.8,1.8,30.8,1.8z M49.1,1.8v19.5h5.2V1.8C54.3,1.8,49.1,1.8,49.1,1.8z"/>
                    <path fill="rgb(229, 231, 235)"
                          d="M100.3,1.8v19.5h5.2V1.8H100.3z M95.6,1.8H80.8l-2.3,2.3v17.2h5.2v-7.1h8.9v7.1h5.2V4.1C97.8,4.1,95.6,1.8,95.6,1.8z M92.7,8.9h-8.9V7h8.9V8.9z"/>
                    <path fill="url(#prideGradient)" d="M46.7,16.2v5.1h-5.1"/>
                </g>
            </svg>
        </a>
    </div>
</div>

<script>
  // Constants
  const FALLBACK_IMAGE = 'https://www.aloshy.ai/images/bg.png';
  const ROTATION_INTERVAL = 10000; // 10 seconds
  const FULLSCREEN_DELAY = 1000; // 1 second

  const CACHE_CONFIG = {
    maxImages: 50,           // Maximum number of images to store
    cacheExpiry: 24 * 3600, // Cache expiry in seconds (24 hours)
    storageKey: 'imageCache',
    urlsKey: 'imageCacheUrls'
  };

  // Default parameters
  const DEFAULT_PARAMS = {
    limit: 100,
    nsfw: 'None',
    sort: 'Most Reactions',
    period: 'Month',
    page: 1
  };

  class ImageCache {
    constructor(config = CACHE_CONFIG) {
      this.config = config;
      this.supportedStorage = this.checkStorageSupport();
    }

    checkStorageSupport() {
      try {
        const storage = {
          localStorage: !!window.localStorage,
          indexedDB: !!window.indexedDB
        };
        return storage;
      } catch (e) {
        console.warn('Storage not available:', e);
        return {localStorage: false, indexedDB: false};
      }
    }

    async storeImageBlob(url, blob) {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('ImageDB', 1);

        request.onerror = () => reject(new Error('IndexedDB access denied'));

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains('images')) {
            db.createObjectStore('images', {keyPath: 'url'});
          }
        };

        request.onsuccess = (event) => {
          const db = event.target.result;
          const transaction = db.transaction(['images'], 'readwrite');
          const store = transaction.objectStore('images');

          const item = {
            url,
            blob,
            timestamp: Date.now()
          };

          store.put(item).onsuccess = () => resolve();
        };
      });
    }

    async getImageBlob(url) {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('ImageDB', 1);

        request.onerror = () => reject(new Error('IndexedDB access denied'));

        request.onsuccess = (event) => {
          const db = event.target.result;
          const transaction = db.transaction(['images'], 'readonly');
          const store = transaction.objectStore('images');

          const getRequest = store.get(url);

          getRequest.onsuccess = () => {
            const item = getRequest.result;
            if (item && Date.now() - item.timestamp < this.config.cacheExpiry * 1000) {
              resolve(item.blob);
            } else {
              resolve(null);
            }
          };
        };
      });
    }

    storeImageUrls(urls) {
      if (!this.supportedStorage.localStorage) return;

      const cachedUrls = {
        urls: urls.slice(0, this.config.maxImages),
        timestamp: Date.now()
      };

      try {
        localStorage.setItem(this.config.urlsKey, JSON.stringify(cachedUrls));
      } catch (e) {
        console.warn('localStorage quota exceeded:', e);
      }
    }

    getImageUrls() {
      if (!this.supportedStorage.localStorage) return null;

      try {
        const cached = JSON.parse(localStorage.getItem(this.config.urlsKey));
        if (cached && Date.now() - cached.timestamp < this.config.cacheExpiry * 1000) {
          return cached.urls;
        }
      } catch (e) {
        console.warn('Error retrieving cached URLs:', e);
      }
      return null;
    }

    async preloadImages(urls) {
      const preloadPromises = urls.map(async (url) => {
        try {
          // Check if image is already cached
          const cachedBlob = await this.getImageBlob(url);
          if (cachedBlob) return url;

          // Fetch and cache new image
          const response = await fetch(url);
          const blob = await response.blob();
          await this.storeImageBlob(url, blob);
          return url;
        } catch (e) {
          console.warn(`Failed to preload image: ${url}`, e);
          return null;
        }
      });

      return (await Promise.all(preloadPromises)).filter(url => url !== null);
    }

    async clearExpiredCache() {
      if (this.supportedStorage.indexedDB) {
        const request = indexedDB.open('ImageDB', 1);

        request.onsuccess = (event) => {
          const db = event.target.result;
          const transaction = db.transaction(['images'], 'readwrite');
          const store = transaction.objectStore('images');

          const cursorRequest = store.openCursor();

          cursorRequest.onsuccess = (e) => {
            const cursor = e.target.result;
            if (cursor) {
              if (Date.now() - cursor.value.timestamp > this.config.cacheExpiry * 1000) {
                store.delete(cursor.key);
              }
              cursor.continue();
            }
          };
        };
      }

      if (this.supportedStorage.localStorage) {
        const cached = this.getImageUrls();
        if (!cached) {
          localStorage.removeItem(this.config.urlsKey);
        }
      }
    }
  }

  // Global variables
  let imageCache = [];
  let currentImageIndex = 0;
  let backgrounds = document.querySelectorAll('.background');
  let activeIndex = 0;
  let isTransitioning = false;

  function getQueryParams() {
    const urlParams = new URLSearchParams(window.location.search);
    const params = {...DEFAULT_PARAMS};

    if (urlParams.has('limit')) {
      const limit = parseInt(urlParams.get('limit'));
      params.limit = Math.min(Math.max(0, limit), 200);
    }

    if (urlParams.has('nsfw')) {
      const nsfw = urlParams.get('nsfw').toLowerCase();
      const validNsfw = {
        'none': 'None',
        'soft': 'Soft',
        'mature': 'Mature',
        'x': 'X'
      };
      if (validNsfw[nsfw]) {
        params.nsfw = validNsfw[nsfw];
      }
    }

    if (urlParams.has('sort')) {
      const sort = urlParams.get('sort').toLowerCase();
      const validSort = {
        'most reactions': 'Most Reactions',
        'mostreactions': 'Most Reactions',
        'most comments': 'Most Comments',
        'mostcomments': 'Most Comments',
        'newest': 'Newest'
      };
      if (validSort[sort]) {
        params.sort = validSort[sort];
      }
    }

    if (urlParams.has('period')) {
      const period = urlParams.get('period').toLowerCase();
      const validPeriod = {
        'alltime': 'AllTime',
        'year': 'Year',
        'month': 'Month',
        'week': 'Week',
        'day': 'Day'
      };
      if (validPeriod[period]) {
        params.period = validPeriod[period];
      }
    }

    if (urlParams.has('page')) {
      const page = parseInt(urlParams.get('page'));
      if (page > 0) {
        params.page = page;
      }
    }

    if (urlParams.has('credits')) {
      const credits = urlParams.get('credits').toLowerCase();
      params.credits = credits === 'true' || credits === '1';
    } else {
      params.credits = true; // default to showing credits
    }

    return params;
  }

  // Fisher-Yates shuffle function
  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  async function fetchImageUrls() {
    try {
      const imageCache = new ImageCache();

      // Try to get cached URLs first
      const cachedUrls = imageCache.getImageUrls();
      if (cachedUrls && cachedUrls.length > 0) {
        return cachedUrls;
      }

      const params = getQueryParams();
      const queryString = new URLSearchParams({
        limit: params.limit,
        nsfw: params.nsfw,
        sort: params.sort,
        period: params.period,
        page: params.page
      }).toString();

      const response = await fetch(`https://civitai.com/api/v1/images?${queryString}`, {
        headers: {'Content-Type': 'application/json'}
      });

      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

      const data = await response.json();

      let filteredItems = data.items;
      if (params.nsfw.toLowerCase() === 'x') {
        filteredItems = filteredItems?.filter(item =>
                item.nsfw === true && item.nsfwLevel === 'X'
        );
      } else if (params.nsfw.toLowerCase() === 'none') {
        filteredItems = filteredItems?.filter(item =>
                item.nsfw === false && item.nsfwLevel === 'None'
        );
      }

      const urls = shuffle(filteredItems?.map(item => item.url) || []);

      imageCache.storeImageUrls(urls);
      await imageCache.preloadImages(urls);

      await imageCache.clearExpiredCache();

      return urls;
    } catch (error) {
      console.warn('Error fetching images:', error);
      return null;
    }
  }

  async function transition() {
    if (isTransitioning || imageCache.length === 0) return;

    try {
      isTransitioning = true;
      const nextIndex = (activeIndex + 1) % 2;

      backgrounds[nextIndex].src = imageCache[currentImageIndex];

      await new Promise(resolve => setTimeout(resolve, 100));

      backgrounds[activeIndex].classList.remove('active');
      backgrounds[nextIndex].classList.add('active');

      activeIndex = nextIndex;
      currentImageIndex = (currentImageIndex + 1) % imageCache.length;

      setTimeout(() => {
        isTransitioning = false;
      }, 2000);
    } catch (error) {
      console.warn('Error during transition:', error);
      isTransitioning = false;
    }
  }

  function showFallback() {
    backgrounds.forEach(bg => {
      bg.src = FALLBACK_IMAGE;
      bg.classList.remove('active');
    });
    backgrounds[0].classList.add('active');
  }

  async function requestFullscreen() {
    try {
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
        await elem.requestFullscreen();
      } else if (elem.webkitRequestFullscreen) {
        await elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        await elem.msRequestFullscreen();
      }
    } catch (error) {
      console.warn('Fullscreen request failed:', error);
    }
  }

  // Initialize everything
  async function initializeImageRotation() {
    try {
      const params = getQueryParams();
      const creditsContainer = document.querySelector('.credits-container');
      if (creditsContainer) {
        creditsContainer.style.display = params.credits ? 'flex' : 'none';
      }

      const imageCacheInstance = new ImageCache();
      const urls = await fetchImageUrls();

      if (!urls || urls.length === 0) {
        showFallback();
        return;
      }

      imageCache = urls;

      // Set up first image
      backgrounds[0].src = imageCache[0];
      backgrounds[0].classList.add('active');
      currentImageIndex = 1;

      // Request fullscreen after delay
      setTimeout(requestFullscreen, FULLSCREEN_DELAY);

      // Start rotation
      setInterval(transition, ROTATION_INTERVAL);
    } catch (error) {
      console.warn('Error in initialization:', error);
      showFallback();
    }
  }

  // Start everything when the page loads
  window.addEventListener('load', initializeImageRotation);
</script>
</body>
</html>
